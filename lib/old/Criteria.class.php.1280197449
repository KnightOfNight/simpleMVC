<?php


/**
* @author >X @ MCS 'Net Productions
* @package MVCAPI
* @version v0.0.0
*/


/**
* Manage all of the criteria for a database select: which columns get selected,
* what sort order to use, where clause, etc.
* All column names are expected to be fully qualified, e.g. <table>.<column>
* @package MVCAPI
*/
class Criteria {
	# Private variables.

	# Array of database model objects.
	private $_models = array();


	# Hash of table information (<table name> => <table alias>)
#	private $_tables = array();

#	private $_columns = array();




	private $_select_cols = array();

	private $_left_joins = array();

	private $_order_by = "";
	private $_order = "";

	private $_where = array();

	private $_limit = 0;

	private $_page = 0;


	# Operators that can be used when building a where clause.
	const op_and = "AND";
	const op_or = "OR";
	const op_gt = ">";
	const op_ge = ">=";
	const op_eq = "=";
	const op_le = "<=";
	const op_lt = "<";
	const op_like = "LIKE";
	const op_notlike = "LIKE";
	const op_is = "IS";
	const op_isnot = "IS NOT";

	# Sort orders.
	const ord_asc = "ASC";
	const ord_desc = "DESC";


#	# Boolean
#	static $AND = "AND";
#	static $OR = "OR";
#
#	# Arithmetic
#	static $GT = ">";
#	static $GE = ">=";
#	static $EQ = "=";
#	static $LE = "<=";
#	static $LT = "<";
#
#	# Like, not like (used for string searches)
#	static $LIKE = "LIKE";
#	static $NOTLIKE = "NOT LIKE";
#
#	# Is, is not (used for null)
#	static $IS = "IS";
#	static $ISNOT = "IS NOT";
#
#	# Sort orders
#	#
#	static $ASC = "ASC";
#	static $DESC = "DESC";



	/**
	* Create a new Criteria object.
	* <code>
	* $criteria = new Criteria(new DatabaseModel($this->db));
	* </code>
	* @param BaseModel an instance of a BaseModel object
	* @return Criteria
	*/
	function __construct (BaseModel $model) {
		if (! ($model instanceof BaseModel)) {
			Error::fatal ("passed model is not an instance of BaseModel");
		}

		$this->_addModel ($model);
	}


	/**
	* Select columns to be returned in the query.
	* @param array list of fully qualified column names (<table>.<column>)
	* <code>
	* $criteria->selectCols (array ("table1.col1", "table1.col2"));
	* </code>
	*/
	function selectCols ($cols = NULL) {
		if (is_null ($cols)) {
			Error::fatal ("list of columns must be specified");
		} elseif (! is_array ($cols)) {
			Error::fatal ("list of columns must be an array of column names");
		}

#			if (empty ($this->_select_cols)) {
#				$select_cols = array();
#				foreach ($this->_columns as $model => $cols) {
#					foreach ($cols as $col) {
#						$col_name = $model . "." . $col;
#						$col_alias = str_replace (".", "_", $col_name);
#						$select_cols[$col_name] = $col_alias;
#					}
#				}
#				return ($select_cols);
#			} else {
#				return ($this->_select_cols);
#			}

		foreach ($cols as $col) {
			if ($this->_checkColumn ($col)) {
				$this->_select_cols[$col] = str_replace (".", "_", $col);
			} else {
				Error::fatal (sprintf ("invalid column '%s'", $col));
			}
		}
	}


	/**
	* Select an expression to be returned in the query.
	* <code>
	* $criteria->selectExpression ("concat(col1, \" \" , col2)", "col1_and_col2");
	* </code>
	* @param string MySQL expression
	* @param string column alias for the expression result
	*/
	function selectExpression ($expression, $alias) {
		if (is_null ($expression) AND is_null ($alias)) {
			Error::fatal ("expression and alias must both be specified");
		}

		$this->_select_cols[$expression] = $alias;
	}


	/**
	* Add a left join to the query.
	* <code>
	* $criteria->addLeftJoin(new Table2Model($this->db), "table1.id", "table2.table1_id");
	* </code>
	* @param BaseModel database model object
	* @param string column A
	* @param string column B
	*/
	function addLeftJoin (BaseModel $model, $colA, $colB) {
		$this->_addModel ($model);

		if ($this->_checkColumn ($colA) AND $this->_checkColumn ($colB)) {
			array_push ($this->_left_joins, array ($model->getTable(), $colA, $colB));
		} else {
			Error::fatal (sprintf ("either column '%s' or column '%s' is not valid", $colA, $colB));
		}
	}


	/**
	* Add a where clause to the query.
	* <code>
	* $criteria->addWhere (array (array ("table1.col1", Criteria::op_eq, "value")));
	*
	* # The following two are equivalent.
	* $criteria->addWhere (array (array ("table1.col1", Criteria::op_eq, "value1"),
	*     Criteria:op_or, array ("table1.col1", Criteria::op_eq, "value2")));
	* $criteria->addWhere (array (array ("table1.col1", Criteria::op_eq, "value1")));
	* $criteria->addWhere (array (array ("table1.col1", Criteria::op_eq, "value2")),
	*    Criteria::op_or);
	*
	* # The following two are equivalent.
	* $criteria->addWhere (array (array ("table1.col1", Criteria::op_ne, "value1"),
	*     Criteria:op_and, array ("table1.col1", Criteria::op_ne, "value2")));
	* $criteria->addWhere (array (array ("table1.col1", Criteria::op_ne, "value1"),
	*     array ("table1.col1", Criteria::op_ne, "value2")));
	* </code>
	* @param array list of clauses
	* @param string Criteria::op_and or Criteria::op_or
	*/
	function addWhere ($clauses = NULL, $andor = NULL) {
		if (is_null ($clauses)) {
			Error::fatal ("list of clauses must be specified");
		}

		if (is_null ($andor)) {
			$andor = Criteria::op_and;
		}

		$parsed_clauses = array();

		for ($idx = 0; $clause = $clauses[$idx]; $idx++) {
			if (is_array ($clause)) {
				if (is_array ($last_clause)) {
					array_push ($parsed_clauses, Criteria::op_and);
				}

				$col = $clause[0];
				$op = $clause[1];
				$val = $clause[2];

				if (! $this->_checkColumn ($col)) {
					Error::fatal (sprintf ("invalid column '%s'", $col));
				}

				if (! $this->_checkOperator ($op)) {
					Error::fatal (sprintf ("invalid operator '%s'", $op));
				}
			} else {
				if ( (! is_array ($last_clause)) OR (! is_array ($clauses[$idx + 1])) ) {
					Error::fatal ("list of clauses invalid: found operator out of place");
				}

				if (($clause != Criteria::op_and) AND ($clause != Criteria:op_or)) {
					Error::fatal (sprintf ("list of clauses invalid: found invalid operator '%s'", $clause));
				}
			}

			array_push ($parsed_clauses, $clause);

			$last_clause = $clause;
		}

		array_push ($this->_where, array ($andor, $parsed_clauses));
	}


#	function andWhere ($sub_clauses, $inter_sub_clause_operator = NULL) {
#		if (is_null ($inter_sub_clause_operator)) {
#			$inter_sub_clause_operator = Criteria::$AND;
#		}
#		$this->_where (Criteria::$AND, $sub_clauses, $inter_sub_clause_operator);
#	}


#	function orWhere ($sub_clauses, $inter_sub_clause_operator = NULL) {
#		if (is_null ($inter_sub_clause_operator)) {
#			$inter_sub_clause_operator = Criteria::$AND;
#		}
#		$this->_where (Criteria::$OR, $sub_clauses, $inter_sub_clause_operator);
#	}


#	function _clause ($col = NULL, $operator = NULL, $value = NULL) {
#		if (is_null ($col) OR is_null ($operator) OR is_null ($value)) {
#			Error::fatal ("column name, operator, and value must all be specified");
#		}
#
#		if ($this->_checkColumn ($col)) {
#			return (array ("column" => $col, "operator" => $operator, "value" => $value));
#		} else {
#			Error::fatal (sprintf ("invalid column '%s'", $col));
#		}
#	}


	/**
	* Get list of all left joins.
	* @return mixed
	*/
	function getLeftJoins () {
		return ($this->_left_joins);
	}


	/**
	* Get the limit on the number of rows returned by the query.
	* @return integer
	*/
	function getLimit () {
		return ($this->_limit);
	}


	/**
	* Get the sort order: ascending or descending.
	* @return string Criteria::ord_asc or Criteria::ord_desc
	*/
	function getOrder () {
		return ($this->_order);
	}


	/**
	* Get the list of columns by which the results are to be ordered.
	* @return string
	*/
	function getOrderBy () {
		return ($this->_order_by);
	}


	/**
	* Get the number of the page within the result set.
	* @return integer
	*/
	function getPage () {
		return ($this->_page);
	}


	/**
	* Get the current list of columns and expressions to be selected.
	* @return array
	*/
	function getSelect () {
		return ($this->_select_cols);
	}


	/**
	* Get the name of the first model associated with this criteria, AKA the primary one in the query.
	* @return string
	*/
	function getModel () {
		return ($this->_models[0]);
	}


#	/**
#	* Get the alias for a database table.
#	* @param string
#	*/
#	function getTableAlias ($table = NULL) {
#		if (is_null ($table)) {
#			Error::fatal ("table name must be specified");
#		} elseif (! isset ($this->_tables[$table])) {
#			Error::fatal (sprintf ("no alias found for table '%s'", $table));
#		}
#
#		return ($this->_tables[$table]);
#	}


	/**
	* Get all of the where clauses for the query.
	* @return mixed
	*/
	function getWhere () {
		return ($this->_where);
	}


	/**
	* Set the limit on the number of rows returned by the query.
	* @param integer
	*/
	function setLimit ($limit = NULL) {
		if ($limit < 0) {
			$limit = 0;
		}

		$this->_limit = $limit;
	}


	/**
	* Set the list of columns and sort order by which the results should be
	* ordered.
	* @param array list of fully qualified column names (<table>.<column>)
	* @param string Criteria::ord_asc or Criteria::ord_desc
	*/
	function setOrderBy ($cols = NULL, $order = NULL) {
		if (is_null ($cols)) {
			Error::fatal ("list of columns must be specified");
		} elseif (! is_array ($cols)) {
			Error::fatal ("list of columns must be an array");
		}

		if (is_null ($order)) {
			$order = Criteria::ord_asc;
		} elseif ( ($order != Criteria::ord_asc) AND ($order != Criteria::ord_desc) ) {
			Error::fatal (sprintf ("invalid sort order '%s'", $order));
		}

		foreach ($cols as $col) {
			if (! $this->_checkColumn ($col)) {
				Error::fatal (sprintf ("invalid column '%s'", $col));
			}
		}

		$this->_order_by = implode (",", $cols);

		$this->_order = $order;
	}


	/**
	* Set the number of the page within the result set.
	* @param integer
	*/
	function setPage ($page = NULL) {
		if ($page < 1) {
			$page = 1;
		}

		$this->_page = $page;
	}


	/**
	* Clear the sort order.
	*/
	function clearOrder () {
		$this->_order_by = "";
		$this->_order = "";
	}


	/**
	* Clear the list of selected columns and expressions.
	*/
	function clearSelect () {
		$this->_select_cols = array();
	}


	/**
	* Clear the list of where clauses.
	*/
	function clearWhere () {
		$this->_where = array();
	}


#	private function _where ($andor, $clauses) {
#		if ( ($andor != Criteria::op_and) AND ($andor != Criteria::$op_or) ) {
#			Error::fatal (sprintf ("invalid operator '%s'", $andor));
#		}
#
#		if (! is_array ($clauses)) {
#			Error::fatal ("list of clauses must be an array");
#		}
#
#		if ( ($inter_sub_clause_operator != Criteria::$AND) AND ($inter_sub_clause_operator != Criteria::$OR) ) {
#			Error::fatal (sprintf ("invalid inter-sub-clause operator '%s'", $inter_sub_clause_operator));
#		}
#
#		for ($idx = 0; $clause = $clauses[$idx]; $idx++) {
#			if (is_array ($idx)) {
#			}
#			$clause = $this-
#		}
#
#		$sub_clause_array = array();
#		foreach ($sub_clauses as $sub_clause) {
#			if (! is_array ($sub_clause)) {
#				Error::fatal ("each individual sub-clause must be an array");
#			}
#			array_push ($sub_clause_array, array ("operator" => $inter_sub_clause_operator, "sub_clause" => $sub_clause));
#		}
#
#		array_push ($this->_where, array ("operator" => $andor, "clauses" => $clauses));
#	}


	/**
	* Associate a database model with this criteria.
	*/
	private function _addModel (BaseModel $model) {
		if (! ($model instanceof BaseModel)) {
			Error::fatal ("passed model is not an instance of BaseModel");
		}

#		array_push ($this->_models, $model);
#
#		array_push ($this->_tables, $table = $model->getTable());
#
#		$this->_tables[$table] = $model = $model->getModel();
#
#		$this->_columns[$model] = $model->getColNames();
	}


	private function _checkColumn ($col) {
		$col_parts = explode (".", $col);

		$model_name = $col_parts[0];
		$col_name = $col_parts[1];

		foreach ($_models as $model) {
			if ($model_name == $model->getName()) {
				if (in_array ($col_name, $model->getColNames())) {
					return (TRUE);
				} else {
					Error::fatal (sprintf ("column '%s' not found in database model", $col));
				}
			}
		}

		Error::fatal (sprintf ("invalid column '%s', database model has not been loaded", $col));
	}


	private function _checkOperator ($op) {
		return (	($op === Criteria:op_and)	OR
					($op === Criteria:op_or)	OR
					($op === Criteria:op_gt)	OR
					($op === Criteria:op_ge)	OR
					($op === Criteria:op_eq)	OR
					($op === Criteria:op_le)	OR
					($op === Criteria:op_lt)	OR
					($op === Criteria:op_like)	OR
					($op === Criteria:op_notlike)	OR
					($op === Criteria:op_is)	OR
					($op === Criteria:op_isnot)
				);
	}


	function __destruct () {}
}
